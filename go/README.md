# GO

---

## 3 集成开发环境以及开发工具

---

### 3.4 构建并运行Go程序
+ `go build` 编译并安装自身包和依赖包
+ `go install` 安装自身包和依赖包

### 3.5 格式化代码
`go fmt` 这个工具可以将源代码格式化成符合官方统一标准的风格，**必须在编译或者提交版本管理系统之前使用`go fmt`来格式化代码**

`go fmt`命令的使用：

+ `gofmt -w program.go` 会格式化源代码文件并覆盖它，`-w`如果不加的话，只会打印格式化后的源代码并不会重写文件
+ `gofmt -w *.go0` 格式化并重写所有Go文件
+ `gofmt map1` 会格式化并重写map1目录以及其子目录下所有Go源文件
+ `gofmtr -r <原始内容> -> <替换内容>`其中`-r`可以实现源代码替换
    ```cmd
    # 将源文件中没有意义的括号去掉
    gofmt -r '(a) -> a' –w *.go
    # 会将源文件中多余的 len(a) 去掉
    gofmt –r 'A.Func1(a,b) -> A.Func2(b,a)' –w *.go
    ```

### 3.6 生成代码文档
`go doc`工具会从Go程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档

一般用法：
+ `go doc package`获取包的文档注释，例如`go doc fmt`
+ `go doc package/subpackage`获取子包的文档注释
+ `go doc package function`获取某个函数在某个某个包中的文档注释，例如`go doc fmt printf`

`godoc --http=:6060`，可以在浏览器中打开**http://localhost:6060**，产看本地文档浏览服务器提供的页面

### 3.7 其它工具
+ `go install` 安装Go包的工具
+ `go fix` 将Go代码从旧的发行版本迁移到最近的发行版
+ `go test` 一个轻量级的单元测试框架

## 4 基本结构和基本数据类型

---

### 4.1 文件名、关键字和标识符

Go的源文件 `.go`

#### 4.4.2 值类型和引用类型
**int**、**float**、**bool**、**string**这些基本类型属于值类型，使用这些值类型的变量都是直接指向内存中的值

#### 4.4.3 打印
使用`fmt.Printf(format string, list of variables to be printed)`

格式化标识符：
+ `%..` 其中`..`可以被不同类型所对应的标识符替换
+ `%s`,代表字符串标识符
+ `%v`,表示使用类型的默认输出格式的标识符

#### 4.5.2.3 位运算
`%b`是用于表示位的格式化标识符
+ `&`:按位与
+ `|`:按位或
+ `^`:按位异或
+ `&^`:位清除，将指定位置上的值设置为0
+ `<<`:位左移
+ `>>`:位右移

#### 4.5.3 运算符与优先级
```text
1.      优先级    运算符
2.      7        ^ !
3.      6        * / % << >> & &^
4.      5        + - | ^
5.      4        == != < <= >= >
6.      3        <-
7.      2        &&
8.      1        ||
```

## 5 控制结构

---

Go提供了以下条件结构和分支结构：
+ if-else 
+ switch
+ select 结构， 用于channel的选择

可以使用迭代或循环结构来重复执行一次或多次某段代码
+ for(range) 结构

## 6 函数

---
Go中的三种类型的函数：
+ 普通的带有名字的函数
+ 匿名函数或者lambda函数
+ 方法

### 6.2.1 call by value && call by reference

Go默认使用**按值传递**来传递参数，也就是传递参数的副本。在函数中对副本的值进行更改，并不会影响到原来的变量

如果想要直接修改参数的值，可以使用**引用传递**，此时传递给函数的是一个指针（引用传递时，指针的值（一个地址）会被复制，
但是指针的值所指向的地址上的值不会被复制；可以通过这个指针的值来修改这个值所指向的地址上的值）

> 注：指针也是变量类型，有自己的地址和值，通常指针的值是一个指向另一变量的地址，所以，按引用传递也是按值传递

在函数调用时，slice、map、interface、channel这样的引用类型默认使用按引用传递（即没有显式的指出指针）

## 7 数组和切片

---

### 7.2.4 new() && make()
+ new(T)为每个新的类型T分配一片内存，初始化为0并返回类型为*T的内存地址；适用于值类型例如数组和结构体
+ make(T,<len>,<cap>)返回一个类型为T的初始值，它只适用于3中内建的引用类型：slice、map和channel

### 7.4 切片重组(reslice)
即切片在达到容量上限后可以扩容。改变切片长度的过程称为**切片重组reslicing**

## 8 Map

---
map是一种特殊的数据结构；一种元素对（pair）的**无序集合**。

## 9 包(package)

